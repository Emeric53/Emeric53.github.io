---
title: ssh 和 tmux 捣鼓
categories:
  - 技术
tags:
  - 终端
  - 教程
---
# ssh 和 tmux 捣鼓
上周在办公室被机房的温度弄得非常烦躁，然后在一个晚上决定把 ssh 好好弄一弄，实在不行就搬到二楼大厅去办公，远程连接到办公室的主机，也还能正常进行代码编辑和执行的工作。结果不知不觉就从十点多捣鼓到了凌晨一点多，要不是觉得第二天还得正常上班，可能还不会停下来。学习和复习了很多 ssh 相关的知识，也了解到了 tmux 这个工具，解决了之前使用 ssh 的一个主要痛点——ssh连接一旦断开，代码执行也随之断开了。感觉只是暂时借用了主机电脑的性能，而不是真正的远程开发。

虽然我目前的用法只能局限于局域网内使用，因为国内互联网提供商一般不给家庭宽带提供固定的公网 IP,同时我的大部分使用场景也限制在研究所里面，其中的子网结构太过复杂了。当然我也知道一些偏方应该能进行映射和解决，但是学习和调试成本过高了。现在基于局域网的 ssh 已经能满足我的目前的需求，对我学习 ssh 等也没有影响。未来购置一些 vps 机器，或者是能用上具有公网 ip 的网络环境，这些技能应该可以直接复用。

本文就简单记录一下 ssh 和 tmux 的使用方式和我的一些使用心得吧。

## SSH
ssh，全称是 secure shell，是一种网络加密远程访问协议，可以用来远程登录和访问互联网上另一台主机的资源并执行命令。ssh 的使用一大核心就是私钥和公钥的加密解密机制，在当前电脑上创建一对新的密钥，并将公钥传输到目标主机上，在使用 ssh 进行远程连接的时候，就可以直接登录了。当然也可以直接使用目标主机的账户和密码进行登录，但是这样安全性较低，其次要输入的东西更繁琐。

我之前对公钥和私钥的放置理解较差，总是弄反。我现在觉得可以用这样的方式来理解：公钥其实是一把门锁，而私钥是这个门锁的钥匙，我想要控制别人的电脑，就像是给别人房子的其中一个门装上这个门锁，这个门锁当然也可以装在其他房子的门上，对应其他的目标主机。而访问这些目标主机的方式就是使用私钥进行用户验证。私钥是不可分享的，而公钥可以随意传给任何一台你想访问的电脑，当然前提是你已经可以控制这台电脑了。感觉其中的逻辑还是有点复杂，以后有时间再好好研究一下。

SSH 的使用方式在经过逐步的优化后，就挺简单了，默认的 ssh 连接命令应该是 `ssh username@server_address`，其中 `username` 是目标主机的用户名，`server_address` 是目标主机的 ip 地址。在这之后可能就需要输入密码进行验证，如果已经配置了密钥，就可以直接登录了。

一个好方法就是使用 ssh 的配置文件，在 `~/.ssh/config` 文件中配置好目标主机的连接信息，就可以直接使用 `ssh server_name` 命令进行连接了。面对局域网中 ssh 的场景，一个典型的使用案例就是固定各个主机的局域网 ip 地址，然后再配置文件中制定好用户名，ip 地址，端口号和密钥路径等信息，甚至还可以给不同的机器单独的访问名称，这样以后就可以直接使用 `ssh server_name` 命令进行连接了。例如，我目前就给我的实验室大主机命名为了 `lab`，有需要的话在终端中直接 `ssh lab` 就可以连接到这台电脑了。类似 VS Code 等 ide 中一般也支持 ssh 远程连接，他们可以直接读取到 ssh 的配置文件，使用起来就像是在本地的编程项目一样了。

到这里就已经讲完了我对 ssh 使用方式的大部分内容了，但是之前就存在一个问题，当我使用 ssh 连接到另一个主机并执行某段代码的时候，如果此时我的 ssh 连接断开了（无论主动或被动），那么正在运行的代码也会随之中断。这在运行一些耗时较长的代码的时候就非常不方便了，接下来就要引入 tmux 这个工具了。

## tmux
tmux 全程是 terminal multiplexer，也就是终端复用器。这个工具的主要作用我觉得就是会话的持久化和管理。从层级来说，tmux 可以分为 session,window和panel 三个层级，其中 session 是最高级，了解这个的用法其实也就掌握了一大半了。

使用 `tmux new -s session_name` 命令就可以创建一个新的 session，其中 `session_name` 是 session 的名称，可以自定义。例如，如果当前我想开展一个代码编辑的工作，就可以使用 `tmux new -s code` 命令创建一个新的 session。这个会话看上去和原先的终端没什么两样，但是我可以通过 `ctrl+b` 和 `d` 两个按键的组合，将这个 session 从当前终端中分离出去，然后就可以进行其他的工作了。之后如果想重新连接到这个 session，只需要使用 `tmux attach -t session_name` 命令就可以重新连接到这个 session 了。如果忘记了当前有哪些 session，可以使用 `tmux ls` 命令查看当前所有的 session。每个会话都是相互独立的，并且在其中运行的命令和过去的状态也完全保留着。

之后我想简单说明一下 window 和 panel 的用法。window 类似于同一个屏幕上的不同窗口，主要通过  `ctrl b` + `c` 来创建新的一个窗口，然后使用 `ctrl b` + `n` 切换到下一个窗口，`ctrl b` 和 `p` 切换到上一个窗口。这些窗口同属于当前的会话，

panel 则是在当前窗口中创建不同的子面板，进一步进行终端的划分。panel 的创建方式主要有两种，分别是横向划分和竖向划分，对应的命令分别是 `ctrl b` + `%` 和 `ctrl b` + `"`。在创建了 panel 之后，可以使用 `ctrl b` + 方向键来把 focus 切换到不同的 panel。

我的个人用法就是基本只使用一个 session 和 一个 window,然后创建三个 panel 进行终端控制。例如，一个 panel 通过 fastfetch 显示当前主机的基本信息，一个 panel 使用 btop 显示当前主机的资源占用情况，例如 cpu 和 gpu 的使用情况，内存占用情况等，最后一个 panel 则用来进行常规的终端操作。
有时候我也会单独多添加一个 window,专门用来打开一个 opencode 命令行进行 vibe coding,然后在思考和代码生成的过程中，切换到另一个窗口进行别的任务的开展了。

归根到底，这些用法感觉都是尝试最大化利用有限的屏幕空间，同时减少鼠标的使用，最近我也在努力学习和提高我的 vim 操作的熟练度，希望能进一步提升我的编程效率，或者看上去很装逼hhh。

## 总结
感觉没什么好总结的，这就是之前一点点折腾的小经验。主要的一个小心得就是有什么操作上觉得不舒服或者有瓶颈的地方，就去搜搜有没有什么工具或者方法可以优化一下，借助 LLM 或者搜索引擎，其实很大概率能找到一个好方法，然后花费点心思学习和练习一下，长时间来看肯定是值得的。